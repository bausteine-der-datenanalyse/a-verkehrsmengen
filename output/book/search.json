[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Anwendungsbaustein Analyse von Verkehrsmengen",
    "section": "",
    "text": "Einleitung",
    "crumbs": [
      "Einleitung"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Anwendungsbaustein Analyse von Verkehrsmengen",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\nZum erfolgreichen Bearbeiten dieses Anwendungsbausteins benötigen Sie die Inhalte des Methodenbausteins Grundlagen der Statistik [Referenz] und des Werkzeugbausteins Datenmanagements [Referenz]",
    "crumbs": [
      "Einleitung"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Anwendungsbaustein Analyse von Verkehrsmengen",
    "section": "Lernziele",
    "text": "Lernziele\nZiel dieses Bausteines ist es, mit Hilfe der Programmiersprache R Verkehrsmengen, die als CSV-Dateien öffentlich zur Verfügung stehen, auszuwerten und die Ergebnisse in geeigneter Weise grafisch darzustellen.",
    "crumbs": [
      "Einleitung"
    ]
  },
  {
    "objectID": "index.html#verwendete-datensätze",
    "href": "index.html#verwendete-datensätze",
    "title": "Anwendungsbaustein Analyse von Verkehrsmengen",
    "section": "Verwendete Datensätze",
    "text": "Verwendete Datensätze\nDaten von Dauerzählstellen auf Autobahnen der Bundesanstalt für Straßenwesen (BASt)",
    "crumbs": [
      "Einleitung"
    ]
  },
  {
    "objectID": "aufgabenstellung/aufgabe_verkehrsdatenanalyse.html",
    "href": "aufgabenstellung/aufgabe_verkehrsdatenanalyse.html",
    "title": "1  Aufgaben zur Analyse von Verkehrsmengen",
    "section": "",
    "text": "1.1 Aufgabe 1\nErstellen Sie eine Karte des deutschen Autobahnnetzes und stellen Sie in dieser Karte die Verkehrsbelastungen für ein beliebiges Jahr dar.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aufgaben zur Analyse von Verkehrsmengen</span>"
    ]
  },
  {
    "objectID": "aufgabenstellung/aufgabe_verkehrsdatenanalyse.html#aufgabe-2",
    "href": "aufgabenstellung/aufgabe_verkehrsdatenanalyse.html#aufgabe-2",
    "title": "1  Aufgaben zur Analyse von Verkehrsmengen",
    "section": "1.2 Aufgabe 2",
    "text": "1.2 Aufgabe 2\nWählen Sie zwei Zählstellen von Autobahnen im Ballungsraum und zwei weitere Zählstellen von Autobahnen außerhalb eines Ballungsraumes. Führen Sie für die vier Zählstellen folgende Auswertungen durch:\n\nErstellen Sie für jeden Wochentag eine Ganglinie für eine ausgewählte Zählstelle und stellen Sie diese in einem Diagramm dar.\nBestimmen Sie die mittlere werktägliche Verkehrsbelastung (mittlere Stundenwerte dienstags bis donnerstags, ohne Feiertage und außerhalb der Schulferien) und stellen Sie die Ganglinien “Mittlerer Werktag” für jede Zählstelle in einem Diagramm dar. Erstellen Sie mit denselben Filtern (ohne Feiertage und außerhalb der Schulferien) für jede Zählstelle ein Diagramm für Samstage und Sonntage.\nBestimmen Sie die “50. Stunde” der vier Zählstellen und geben das Ergebnis in einer Tabelle aus. Wählen Sie zudem eine geeignete Darstellungsform, um für jede Zählstelle die 50. Stunde im Vergleich zu den restlichen Stunden eines Jahres auszugeben.\nUntersuchen Sie den prozentualen Anteil des Schwerverkehrs in der Zeitspanne 2003 bis 2018. Welche Entwicklung / Tendenz lässt sich erkennen?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aufgaben zur Analyse von Verkehrsmengen</span>"
    ]
  },
  {
    "objectID": "musterloesung/musterloesung.html",
    "href": "musterloesung/musterloesung.html",
    "title": "2  Musterlösung Analyse von Verkehrsmengen",
    "section": "",
    "text": "2.1 Aufgabe 1\nDeutschlandkarte:\nAutobahnnetz:\nFür das wählbare Jahr wurden hier die Zählstellendaten von 2022 verwendet:\nAlle Elemente zusammen plotten:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Musterlösung Analyse von Verkehrsmengen</span>"
    ]
  },
  {
    "objectID": "musterloesung/musterloesung.html#aufgabe-1",
    "href": "musterloesung/musterloesung.html#aufgabe-1",
    "title": "2  Musterlösung Analyse von Verkehrsmengen",
    "section": "",
    "text": "```{r}\nd_de &lt;- gisco_get_nuts(country = \"Germany\", nuts_level = 0, resolution = 03)\n```\n\n```{r}\nif (!file.exists(\"data/d_bab.RData\")) {\n  q &lt;- opq(bbox = getbb(\"Deutschland\", featuretype = \"country\"), timeout = 600)\n  d_bab_raw &lt;- (add_osm_feature(q, key = \"highway\", value = \"motorway\") |&gt; osmdata_sf())$osm_lines\n  d_bab &lt;- d_bab_raw |&gt;\n    filter(st_contains(d_de, d_bab_raw, sparse = FALSE)[1,]) |&gt;\n    drop_na(ref) |&gt;\n    group_by(ref) |&gt;\n    summarise() |&gt;\n    st_simplify(dTolerance = 100) \n  save(d_bab, d_bab_raw, file = \"data/bab.RData\")\n} else {\n  load(file = \"data/d_bab.RData\")\n}\n```\n\n```{r}\n#| warning: false\n\nd_Jawe &lt;- read_csv2(\"data/Jawe2022.csv\", locale = locale(encoding = 'iso-8859-1'))\n```\n```{r}\nd_JaweNA &lt;- d_Jawe |&gt;\n  filter(Str_Kl == \"A\") |&gt;\n  drop_na(DTV_Kfz_MobisSo_Q) |&gt;\n  arrange(DTV_Kfz_MobisSo_Q)\n```\n\n```{r}\nggplot() +\n  geom_sf(data = d_de, fill = NA, size = 0.5) +\n  geom_sf(data = d_bab,  size = 0.35, show.legend = FALSE) +\n  geom_point(data = d_JaweNA, mapping = aes(x = Koor_WGS84_E, y = Koor_WGS84_N, color = DTV_Kfz_MobisSo_Q), size = 1.5, na.rm = FALSE) + \n  scale_color_distiller(palette = 8 , direction = 1) +\n  theme_void()\n```",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Musterlösung Analyse von Verkehrsmengen</span>"
    ]
  },
  {
    "objectID": "musterloesung/musterloesung.html#aufgabe-2",
    "href": "musterloesung/musterloesung.html#aufgabe-2",
    "title": "2  Musterlösung Analyse von Verkehrsmengen",
    "section": "2.2 Aufgabe 2",
    "text": "2.2 Aufgabe 2\n\n2.2.1 a) Tagesganglinien\n\n2.2.1.1 Tagesganglinie einer Zählstelle\nDaten einlesen und verarbeiten\n```{r}\n#| warning: false\nZST5116 &lt;- read_csv2(\"data/zst5116_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\n```\n```{r}\n#| warning: false\nZST5116_DTV &lt;- ZST5116 |&gt; \n  group_by(Stunde, Wotag) |&gt; \n  summarise(avg_KFZ_R1 = mean(KFZ_R1),avg_KFZ_R2 = mean(KFZ_R2))\n\n ZST5116_DTV$Wochentag &lt;- factor(ZST5116_DTV$Wotag,\n  levels = c(1,2,3,4,5,6,7),\n  labels = c(\"Mo\",\"Di\",\"Mi\",\"Do\",\"Fr\",\"Sa\",\"So\"))\n```\nPlotten\n```{r}\n#| warning: false\n\nggplot(data = ZST5116_DTV, aes(x = Stunde, y = avg_KFZ_R1 ,group = Wochentag ,color = factor(Wochentag), shape = Wochentag)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Tagesganglinien Zählstelle 5116 Richtung 1\",\n       x = \"Stunde\",\n       y = \"Verkehrsaufkommen Richtung 1 in Kfz/h\",\n       color = \"Wochentag\",\n      shape = \"Wochentag\") +\n  scale_color_viridis_d() +\n  theme_light()\n```\n\n\n\n2.2.2 b) Tagesganglinien “Mittlerer Werktag”\nExemplarische Beispiele einer Zählstelle\n```{r}\n#| warning: false\n\nZST5116$Wotag &lt;- factor(ZST5116$Wotag,\n levels = c(1,2,3,4,5,6,7),\n labels = c(\"Mo\",\"Di\",\"Mi\",\"Do\",\"Fr\",\"Sa\",\"So\"))\n\n\ndata_werktag &lt;- ZST5116 |&gt;\n  filter(Fahrtzw == \"w\", Wotag %in% c(\"Di\", \"Mi\", \"Do\"))\n\ndata_werktag_mean &lt;- data_werktag |&gt;\n  group_by(Stunde) |&gt;\n  summarise(avg_KFZ_R1 = mean(KFZ_R1),avg_KFZ_R2 = mean(KFZ_R2))\n\ndata_werktag_mean$Anteil = (data_werktag_mean$avg_KFZ_R1/sum(data_werktag_mean$avg_KFZ_R1)*100)\n```\nPlot für Verkehrsaufkommen:\n```{r}\nggplot(data = data_werktag_mean, aes(x = Stunde, y = avg_KFZ_R1, group = 1)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Verkehrsaufkommen mittlerer Werktage Zählstelle 5116 R1\",\n       x = \"Stunde\",\n       y = \"KFZ_R1 in KFZ pro Stunde\") +\n  theme_light()\n```\nPlot für Anteile:\n```{r}\nggplot(data = data_werktag_mean, aes(x = Stunde, y = Anteil, group = 1)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Verkehrsaufkommen mittlerer Werktage Zählstelle 5116 R1\",\n       x = \"Stunde\",\n       y = \"Prozentualer Anteil\") +\n  theme_light()\n```\nMehrere Daten einlesen und verarbeiten\n```{r}\n#| warning: false\nZST5113 &lt;- read_csv2(\"data/zst5113_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\nZST5116 &lt;- read_csv2(\"data/zst5116_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\nZST5125 &lt;- read_csv2(\"data/zst5125_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\nZST5128 &lt;- read_csv2(\"data/zst5128_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\n```\n```{r}\nall_data &lt;- bind_rows(list(ZST5113,ZST5116,ZST5125,ZST5128), .id = \"Zaehlstelle\")\n\nall_data$Zaehlstelle &lt;- factor(all_data$Zaehlstelle, levels = c(\"1\", \"2\", \"3\", \"4\"), labels = c(\"Bochum\", \"Wanne-Eickel\", \"Waltrop-Brambauer\", \"Wenden-Dahl\"))\n\nall_data$Wotag &lt;- factor(all_data$Wotag,\n levels = c(1,2,3,4,5,6,7),\n labels = c(\"Mo\",\"Di\",\"Mi\",\"Do\",\"Fr\",\"Sa\",\"So\"))\n```\n```{r}\n#Werktag\ndata_werktag_all &lt;- all_data |&gt;\n  filter(Fahrtzw == \"w\", Wotag %in% c(\"Di\", \"Mi\", \"Do\"))\n\ndata_werktag_mean_all &lt;- data_werktag_all |&gt;\n  group_by(Stunde, Zaehlstelle) |&gt;\n  summarise(avg_KFZ_R1 = mean(KFZ_R1),avg_KFZ_R2 = mean(KFZ_R2))\n  \n#Samstag\ndata_samstag_all &lt;- all_data |&gt;\n  filter(Fahrtzw == \"w\", Wotag == \"Sa\")\n\ndata_samstag_mean_all &lt;- data_samstag_all |&gt;\n  group_by(Stunde, Zaehlstelle) |&gt;\n  summarise(avg_KFZ_R1 = mean(KFZ_R1),avg_KFZ_R2 = mean(KFZ_R2))\n\n#Sonntag\ndata_sonntag_all &lt;- all_data |&gt;\n  filter(Wotag == \"So\")\n\ndata_sonntag_mean_all &lt;- data_sonntag_all |&gt;\n  group_by(Stunde, Zaehlstelle) |&gt;\n  summarise(avg_KFZ_R1 = mean(KFZ_R1),avg_KFZ_R2 = mean(KFZ_R2))\n```\nPlotten\nPlot für Werktage:\n```{r}\nggplot(data = data_werktag_mean_all, aes(x = Stunde, y = avg_KFZ_R1, group = Zaehlstelle, color = Zaehlstelle)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Verkehrsaufkommen mittlerer Werktage aller Zählstellen\",\n       x = \"Stunde\",\n       y = \"KFZ_R1\",\n       color = \"Wotag\") +\n  scale_color_viridis_d() +\n  theme_light()\n```\nPlot für Samstage:\n```{r}\nggplot(data = data_samstag_mean_all, aes(x = Stunde, y = avg_KFZ_R1, group = Zaehlstelle, color = Zaehlstelle)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Verkehrsaufkommen an Samstagen aller Zählstellen\",\n       x = \"Stunde\",\n       y = \"KFZ_R1\",\n       color = \"Wotag\") +\n  scale_color_viridis_d() +\n  theme_light()\n```\nPlot für Sonntage:\n```{r}\nggplot(data = data_sonntag_mean_all, aes(x = Stunde, y = avg_KFZ_R1, group = Zaehlstelle, color = Zaehlstelle)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Verkehrsaufkommen an Sonntagen aller Zählstellen\",\n       x = \"Stunde\",\n       y = \"KFZ_R1\",\n       color = \"Wotag\") +\n  scale_color_viridis_d() +\n  theme_light()\n```\n\n\n2.2.3 c) 50. Stunde\nStunde auswählen:\n```{r}\nZST5116_50 &lt;- ZST5116 |&gt; \n    arrange(desc(KFZ_R1)) |&gt;\n    slice(50) |&gt;\n  select(Datum,Wotag,Stunde,KFZ_R1)\n```\nAls Tabelle:\n```{r}\nkable(ZST5116_50)\n```\nGeeignete Darstellungsform:\n```{r}\n# Erstellen des Streudiagramms für den stündlichen DTV Zählstelle 5116 Richtung 1\nZST5116_top &lt;- ZST5116 |&gt;\n  arrange(desc(KFZ_R1))\n\nZST5116_top$Nummer = 1:nrow(ZST5116_top)\n```\n```{r}\nggplot(data = ZST5116_top[1:80, ], aes(x = Nummer,y = KFZ_R1, fill = Nummer == 50, width = .65)) +\n  geom_bar(stat = \"identity\") +\n  labs(title = \"Verkehrsaufkommen pro Stunde Zählstelle 5116 Richtung 1\",\n       x = \"Sortierte Topstunde\",\n       y = \"Verkehrsaufkommen in Kfz/h\",\n       legend = \"Wochentag\") +\n  scale_fill_manual(values = c(\"grey\", \"red\"), guide = \"none\") +\n  geom_label(\n    data = filter(ZST5116_top,Nummer == 50), \n    mapping = aes(label = KFZ_R1),\n    nudge_y = 200, size = 4.5, alpha = 0.5\n  ) +\n  theme_light()\n```\n\n\n2.2.4 d) Schwerverkehr\nDaten einlesen und filtern:\n```{r}\n#| warning: false\n\nlist_of_files &lt;- list.files(path = \"data_jw\",\n                            recursive = TRUE,\n                            pattern = \"\\\\.csv$\",\n                            full.names = TRUE)\n\ndf &lt;- readr::read_csv2(list_of_files, id = \"Jahr\", locale = locale(encoding = 'iso-8859-1'))\ndf$Jahr &lt;- str_remove_all(df$Jahr, \"[data_jw/Jawe]\")\ndf$Jahr &lt;- str_remove_all(df$Jahr, \"[.csv]\")\ndf$Jahr &lt;- as.numeric(df$Jahr)\n\ndf_NA &lt;- df |&gt;\n  filter(DTV_Kfz_MobisSo_Q != 'NA' & DTV_SV_MobisSo_Q != 'NA')\n\ndf_schwer &lt;- df_NA |&gt; \n  group_by(Jahr) |&gt; \n  summarise(SV = sum(DTV_SV_MobisSo_Q),Alle = sum(DTV_Kfz_MobisSo_Q),Anteil = (SV/Alle)*100)\n```\nPlotten:\n```{r}\nggplot(data = df_schwer, aes(x = Jahr, y = Anteil)) +\n  geom_bar(stat='identity', fill = \"blue\") +\n  labs(x = \"Jahr\", y = \"Anteil am gesamten Verkehrsaufkommen\") +\n  ggtitle(\"Anteil des Schwerverkehrs von 2003 bis 2018 in 1000\") +\n  scale_x_continuous(breaks=seq(2003,2018,1)) +\n theme_light()\n```",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Musterlösung Analyse von Verkehrsmengen</span>"
    ]
  },
  {
    "objectID": "verkehrsdatenanalyse.html",
    "href": "verkehrsdatenanalyse.html",
    "title": "3  Ausführliche Erläuterung der Musterlösung",
    "section": "",
    "text": "3.1 Aufgabe 1: Deutschlandkarte mit Zählstellendaten\nAls ersten Schritt interessieren uns besonders stark befahrene Streckenabschnitte von Autobahnen und wir wollen diese in einer Deutschlandkarte darstellen. Wir gehen hierbei schrittweise vor:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Ausführliche Erläuterung der Musterlösung</span>"
    ]
  },
  {
    "objectID": "verkehrsdatenanalyse.html#aufgabe-1-deutschlandkarte-mit-zählstellendaten",
    "href": "verkehrsdatenanalyse.html#aufgabe-1-deutschlandkarte-mit-zählstellendaten",
    "title": "3  Ausführliche Erläuterung der Musterlösung",
    "section": "",
    "text": "Erstellung einer Deutschlandkarte.\nHinzufügen des Autobahnnetzes in die Deutschlandkarte.\nDie Daten der Zählstellen in die Deutschlandkarte plotten.\n\n\n3.1.1 Deutschlandkarte\nWie in [Videoquelle] benötigen wir für die Erstellung einer Deutschlandkarte die Pakete giscoR (https://ropengov.github.io/giscoR/), sf (https://r-spatial.github.io/sf/) und ggplot2 (https://ggplot2.tidyverse.org/).\nMithilfe des Pakets giscoR werden geografische Informationen abgerufen, die mithilfe von sf in ggplot2 dargestellt werden können.\nMit dem Befehl gisco_get_nuts() werden NUTS-Regionen als sf (simple feature) Polygone, Punkte und Linien ausgegeben. Wir interessieren uns für die deutschen Grenzen (nuts_level = 0) und wollen diese als Datensatz speichern.\n\nd_de &lt;- gisco_get_nuts(country = \"Germany\", nuts_level = 0, resolution = 03)\n\nDie verwendeten Elemente lassen sich in drei Abschnitte unterteilen:\n\ncountry = gibt an um welches Land es sich handelt.\nnuts_level = gibt Ebene der NUTS an. (0 für Staat, 1 für Bundesländer, 2 für Regierungsbezirke)\nresolution = bestimmt die Auflösung.\n\nFür zusätzliche Informationen ist es hilfreich, die Dokumentation des Pakets zu lesen.\nWeitere Details zu den NUTS(Nomenclature of territorial units for statistics)-Regionen können auf der Seite des Statistischen Amtes der Europäischen Union gefunden werden.\nZur ersten Überprüfung, ob dieser Schritt entsprechend unserer Erwartung funktioniert hat, können wir mithilfe des Datensatzes bereits mit ggplot2 plotten. Dafür leiten wir die erstellten simple features an ggplot2 weiter und visualisieren diese mit der Funktion geom_sf(). Diese Funktion arbeitet nach dem bekannten Muster aus Kapitel [Referenz]. Als zusätzliche Option geben wir mit fill = NA an, dass die Deutschlandkarte nicht farblich eingefärbt werden soll.\n\nggplot() +\n  geom_sf(data = d_de, fill = NA, size = 0.5)\n\n\n\n\n\n\n\n\nWir sehen, dass dies eine funktionierende Deutschlandkarte darstellt. In den weiteren Schritten schauen wir uns an, wie wir weitere Informationen in diese Karte hinzufügen.\n\n\n3.1.2 Autobahnverlauf\nWie in [Videoquelle] benötigen wir für die Erstellung des Autobahnverlaufs das Paket osmdatahttps://cran.r-project.org/web/packages/osmdata/vignettes/osmdata.html. Dieses Paket verwendet Daten auf Grundlage von Open Street Map.\nUm nur die Daten aus Deutschland zu verwenden, müssen wir zuerst eine Anfrage (engl. query) mit der Bounding Box Deutschland erstellen. Die Funktion opq() erstellt die Anfrage und die Funktion getbb() legt den Koordinatenbereich der Bounding Box fest. Wir interessieren uns für \"Deutschland\" und müssen noch spezifieren, dass wir uns für das Land als Merkmal (featuretype = \"country\") interessieren. Diese Anfrage speichern wir als Objekt zur späteren Verwendung ab. Da dieser Prozess länger dauern kann, ist es hilfreich mit timeout = 600 zu spezifizieren, dass dieser Befehl nach 600 Sekunden aufhört, sollte die Ausführung diese Zeit in Anspruch nehmen.\n\n  q &lt;- opq(bbox = getbb(\"Deutschland\", featuretype = \"country\"), timeout = 600)\n\nNun können wir unserer Anfrage Objekte mit der Funktion add_osm_feature() hinzufügen. Mit den Spezifikationen key für die Kategorie und value für die genauen Objekte wird festgelegt, welche Arten von Objekten der Anfrage hinzugefügt werden. In unserem Fall interessieren uns nur die Autobahnen: Ein Blick in die Dokumentation von Open Street Map zeigt uns, dass wir key = \"highway\" und value = \"motorway\" benötigen. Dies leiten wir nun an die Funktion osmdata_sf() weiter, damit unsere Anfrage im simple feature-Format weiterverarbeitet wird. Wir verwenden nur die osm_lines und nicht die anderen Objekte wie osm_points und osm_polygons. Diesen Datensatz speichern wir als d_bab_raw .\n\n  d_bab_raw &lt;- (add_osm_feature(q, key = \"highway\", value = \"motorway\") |&gt; osmdata_sf())$osm_lines\n\nDiese Daten müssen nun noch weiter aufbereitet werden. Dabei handelt es sich um den schwierigsten Schritt in diesem Baustein: Ein Blick in den Datensatz zeigt, dass dort viele für unseren Fall uninteressante Variablen und einige nicht vorhandene Werte vorliegen. Außerdem werden die Autobahnen über die deutschen Grenzen hinaus dargestellt, wir interessieren uns aber momentan nur für die Werte in Deutschland.\nUm nur den Autobahnverlauf in Deutschland dazustellen benötigen wir einen Filter mit filter(). Als Element des Filters verwenden wir die Funktion st_contains() aus dem Paket sf und fügen unsere Datensätze d_de und d_bab_raw ein, sodass nur die Werte aus d_bab_raw übernommen werden, die sich in d_de befinden. Zusätzlich geben wir mit sparse = FALSE an, dass kein “sparse index” ausgegeben werden soll. Mit drop_na(ref) werden alle Reihen exkludiert, die einen nicht vorhandenen (NA englisch für not available) Wert für die Variable ref besitzen. Die Variable ref stellt die Bezeichnung der jeweiligen Autobahn da. Wir wollen also alle Objekte, die nicht zugeordnet werden entfernen.Mit group_by(ref) und summarise() wird der Datensatz nach der ref-Variable gruppiert und alle Reihen mit demselben Wert werden zusammengefasst. Zuletzt verwenden wir st_simplify() um den Autobahnverlauf zu vereinfachen und nicht jeden Eckpunkt darzustellen. Mit dTolerance = stellen wir den Toleranzparameter für unsere Vereinfachung in Metern ein (in unserem Fall beträgt dies 100 Meter). Diesen Datensatz speichern wir als d_bab ab.\n\n  q &lt;- opq(bbox = getbb(\"Deutschland\", featuretype = \"country\"), timeout = 600)\n  d_bab_raw &lt;- (add_osm_feature(q, key = \"highway\", value = \"motorway\") |&gt; osmdata_sf())$osm_lines\n  d_bab &lt;- d_bab_raw |&gt;\n    filter(st_contains(d_de, d_bab_raw, sparse = FALSE)[1,]) |&gt;\n    drop_na(ref) |&gt;\n    group_by(ref) |&gt;\n    summarise() |&gt;\n    st_simplify(dTolerance = 100) \n  save(d_bab, d_bab_raw, file = \"data/bab.RData\")\n\n\n\n\n\n\n\nRechenleistung und Zeit einsparen\n\n\n\nUm zu verhindern, dass die durchaus lange Bearbeitungsdauer der ‘add_osm_features’-Funktion jedes Mal beim Rendern des Dokuments durchgeführt wird, lohnt es sich die rohen RData-Dateien abzuspeichern und mithilfe einer if-Abfrage zu schauen, ob diese Dateien bereits vorhanden sind und dann zu laden. Beispielhaft könnte dies mit einer if-Abfrage so aussehen:\n\nif (!file.exists(\"data/d_bab.RData\")) {\n  q &lt;- opq(bbox = getbb(\"Deutschland\", featuretype = \"country\"), timeout = 600)\n  d_bab_raw &lt;- (add_osm_feature(q, key = \"highway\", value = \"motorway\") |&gt; osmdata_sf())$osm_lines\n  d_bab &lt;- d_bab_raw |&gt;\n    filter(st_contains(d_de, d_bab_raw, sparse = FALSE)[1,]) |&gt;\n    drop_na(ref) |&gt;\n    group_by(ref) |&gt;\n    summarise() |&gt;\n    st_simplify(dTolerance = 100) \n  save(d_bab, d_bab_raw, file = \"data/bab.RData\")\n} else {\n  load(file = \"data/d_bab.RData\")\n}\n\n\n\nWenn man diese Daten nun mit der bereits erstellten Deutschlandkarte kombiniert, erhält man diese Darstellung:\n\nggplot() +\n  geom_sf(data = d_de, fill = NA, size = 0.5) +\n  geom_sf(data = d_bab,  size = 0.35, show.legend = FALSE)\n\n\n\n\n\n\n\n\n\n\n3.1.3 Zählstellendaten\nZuguterletzt fügen wir die tatsächlichen Verkehrsdaten zu unserer Darstellung hinzu. Wir verwenden hier die Daten von Dauerzählstellen auf Autobahnen für das Jahr 2022, die die Bundesanstalt für Straßenwesen (BASt) online zur Verfügung stellt. Die heruntergeladene CSV-Datei importieren wir mithilfe der read_csv2()-Funktion des Pakets readr aus der Paketsammlung tidyverse.\n\nd_Jawe &lt;- read_csv2(\"data/Jawe2022.csv\", locale = locale(encoding = 'iso-8859-1'))\n\nDurch locale = locale(encoding = 'iso-8859-1') bestimmen wir die Kodierung nach der ISO-Norm 8859-1, damit die Datei auch in anderen Systemen geladen werden kann. Danach müssen wir den Datensatz aufbereiten (siehe [Referenz]) und für unseren Zweck relevante Daten filtern (siehe [Referenz]). Dazu benötigen wir die ebenfalls online verfügbare Datensatzbeschreibung der BASt.\nDort sehen wir, dass die Variable Str_Kl die Straßenklasse beschreibt. Diese Variable hat die Ausprägungen “A” für Autobahnen und “B” für Bundesstraßen. In unserem Fall interessieren uns nur die Daten für Autobahnen, also die Ausprägung “A”. Dies können wir mit filter(Str_Kl == \"A\") erreichen.\nDa dieser Datensatz ebenfalls viele nicht vorhandene, sogenannte NA(englisch not available)-Werte beinhaltet, können wir diese ebenfalls herausfiltern. Dies geschieht zum Beispiel mit filter(DTV_Kfz_MobisSo_Q != \"NA\" ). Diese beiden Filter können mit dem Operator “&” verknüpft werden. Eine elegantere Lösung ist die Verwendung der drop_na()-Funktion aus dem Paket tidyr des tidyverse.\nEine weitere Maßnahme für unseren speziellen Fall, ist die Sortierung des Datensatzes: ggplot2 geht den Datensatz von oben nach unten durch, um Datenpunkte zu plotten. Wir wollen aber, dass besonders befahrene Abschnitte vor den anderen Punkte liegen und somit gut sichtbar auf der Karte sind. Dazu benutzen wir die arrange()-Funktion und sortieren den Datensatz aufsteigend nach der Variable DTV_Kfz_MobisSo_Q.\n\nd_JaweNA &lt;- d_Jawe |&gt;\n  filter(Str_Kl == \"A\") |&gt;\n  drop_na(DTV_Kfz_MobisSo_Q) |&gt;\n  arrange(DTV_Kfz_MobisSo_Q)\n\nNun können wir alle Elemente kombinieren: Wir plotten nun also die Deutschlandkarte, die Karte des Autobahnverlaufs und die Daten der Zählstellen in eine Grafik. Ebenfalls in der Datensatzbeschreibung können wir die Variablen für die Länge (Koor_WGS84_E) und Breite (Koor_WGS84_N) der Lagekoordinaten in WGS84 für die jeweilige Zählstelle finden. Diese Werte setzen wir als x-Koordinate und y-Koordinate ein.\nUm die Darstellung zu verschönern, verwenden wir einige zusätzliche Optionen von ggplot2. scale_color_distiller ist Teil der Farbpalette “brewer”, entwickelt von Cynthia Brewer. Mit palette = 8 benutzen wir in unserem Fall die 8. Palette und direction = 1 invertiert die Skala, damit hohe Werte dunkler dargestellt werden und niedrige Werte heller. Mit theme_void sorgen wir dafür, dass ggplot-Thema komplett leer ist, wir also keine Achsen, Achsenbeschriftungen, Hintergründe oder Gitternetzlinien in unserer Grafik sehen.\n\nggplot() +\n  geom_sf(data = d_de, fill = NA, size = 0.5) +\n  geom_sf(data = d_bab,  size = 0.35, show.legend = FALSE) +\n  geom_point(data = d_JaweNA, mapping = aes(x = Koor_WGS84_E, y = Koor_WGS84_N, color = DTV_Kfz_MobisSo_Q), size = 1.5, na.rm = FALSE) + \n  scale_color_distiller(palette = 8 , direction = 1) +\n  theme_void()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Ausführliche Erläuterung der Musterlösung</span>"
    ]
  },
  {
    "objectID": "verkehrsdatenanalyse.html#sec-tagesganglinien",
    "href": "verkehrsdatenanalyse.html#sec-tagesganglinien",
    "title": "3  Ausführliche Erläuterung der Musterlösung",
    "section": "3.2 Aufgabe 2:",
    "text": "3.2 Aufgabe 2:\nAls weitere wichtige Größe in der Verkehrsdatenanalyse schauen wir uns die Tagesganglinien an. Dazu benötigen wir die Daten einer Zählstelle für jeden Tag. Eine Auflistung der Zählstellen und ihres Datensatzes findet sich ebenfalls auf der Seite der BASt.\nExemplarisch verwenden wir hier die Zählstelle 5116 der A42 in Wanne-Eickel. Diese Daten müssen wir zuerst einlesen:\n\nZST5116 &lt;- read_csv2(\"data/zst5116_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\n\nAuch hier hilft es, sich die Datensatzbeschreibung der BASt anzuschauen.\n\n3.2.1 Aufgabe 2 a):Tagesganglinien\n\n3.2.1.1 Einzelne Wochentage\nWir wollen nun die Tagesganglinien der ausgewählten Zählstelle für jeden Wochentag erstellen. Wir brauchen also Mittelwerte für jede Stunde jedes Wochentages. Dazu benötigen wir das Paket dplyr aus der Paketsammlung tidyverse.\nMithilfe der Funktion group_by() können wir unseren Datensatz nach Variablen gruppieren. Für unseren Fall sind dies die Variablen Stunde für die Erhebungsstunde und Wotag für den Wochentag.\nDanach leiten wir diese Werte an die summarise()-Funktion weiter. Diese gibt für jede Kombination der Gruppierungsvariable eine Reihe aus. Dazu benötigen wir für Kombination ebenfalls die Mittelwerte für beide Fahrtrichtungen (KFZ_R1 und KFZ_R2). Diesen Datensatz speichern wir als neues Element ZST5116_DTV. Für die weitere Verwendung bietet es sich an, die Variable Wotag mit factor () in einen Faktor umzuwandeln und die Ebenen des Faktors (levels =) korrekt nach den Wochentagen zu benennen (labels =).\n\nZST5116_DTV &lt;- ZST5116 |&gt; \n  group_by(Stunde, Wotag) |&gt; \n  summarise(avg_KFZ_R1 = mean(KFZ_R1),avg_KFZ_R2 = mean(KFZ_R2))\n\n ZST5116_DTV$Wochentag &lt;- factor(ZST5116_DTV$Wotag,\n  levels = c(1,2,3,4,5,6,7),\n  labels = c(\"Mo\",\"Di\",\"Mi\",\"Do\",\"Fr\",\"Sa\",\"So\"))\n\nNun können wir diese Daten (exemplarisch hier Fahrtrichtung 1 mit KFZ_R1) in ggplot2 verwenden. Wir wollen für eine Tagesganglinie nun für jede Stunde einen Datenpunkt darstellen und diese mit einer Linie verbinden.\nZuerst erstellen wir mit ggplot() unsere Umgebung zum Erstellen von Grafiken. Da wir wie angesprochen zwei Formen (Datenpunkte und Linien) verwenden, bietet es sich an, die Einstellungen wie der verwendete Datensatz und die verwendeten Variablen global in ggplot() und nicht bei den einzelnen Elementen festzulegen. Dazu legen wir mit data = ZST5116_DTV den neu erstellten Datensatz als Datensatz fest. Mit aes() legen wir fest, wie Variablen visuelle Eigenschaften zugeordnet werden. Mit x = Stunde und y = avg_KFZ_R1 bestimmen wir, dass die Stunde auf der X-Achse abgetragen wird und unsere neu erstellten Mittelwerte auf der y-Achse. Wir wollen unsere Daten aber noch nach Wochentagen aufteilen und einfärben und dies geschieht mit group = Wochentag und color = factor(Wochentag). All diese Eigenschaften werden an nachfolgende geoms “weitervererbt”. Mit geom_point fügen wir die Datenpunkte hinzu und mit geom_line die Linie. Die Zusatzoptionen size = 2 und linewidth = 1 verändern die Größe der Elemente und dienen der Ästhetik, sind aber natürlich persönliche Präferenz. Zuguterletzt beschriften wir mit labs() unsere Grafik. Dazu ändern wir mit title = den Titel, mit x = und y = die Beschriftung der jeweiligen Achse und mit color = die Legende für die Farben.\nAls Zusatzoption verwenden wir mit scale_color_viridis_d die Viridisfarbpalette, die so gestaltet wurde, dass Personen mit häufigen Formen von Farbenblindheit diese besser wahrnehmen können.\nMit theme_light() verwenden wir ein vorgefertigtes Thema (https://ggplot2.tidyverse.org/reference/ggtheme.html), um die Darstellungsform aller nicht Daten-Elemente zu steuern. Auch hier handelt es sich natürlich um eine persönliche Präferenz und andere Themen können ebenfalls gewählt werden und gute Grafiken erzeugen.\n\nggplot(data = ZST5116_DTV, aes(x = Stunde, y = avg_KFZ_R1 ,group = Wochentag ,color = factor(Wochentag), shape = Wochentag)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Tagesganglinien Zählstelle 5116 Richtung 1\",\n       x = \"Stunde\",\n       y = \"Verkehrsaufkommen Richtung 1 in Kfz/h\",\n       color = \"Wochentag\",\n      shape = \"Wochentag\") +\n  scale_color_viridis_d() +\n  theme_light()\n\n\n\n\n\n\n\n\n\n\n\n3.2.2 Aufgabe 2 b) Mittlerer Werktag von vier Zählstellen\nFür den Einstieg in das Thema beginnen wir mit einer einzelnen Zählstelle. Die Lösung für mehrere Zählstellen befindet sich weiter unten in diesem Abschnitt.\nHäufig können in der Analyse sogenannte mittlere Werktage verwendet werden, um der Varianz vom Beginn und Ende der Woche zu entgehen. In diesem Fall interessieren uns also die Wochentage Dienstag, Mittwoch und Donnerstag an normalen Werktage außerhalb der Schulferien. Ein Blick in die Datensatzbeschreibung der BASt zeigt uns, dass diese Unterteilung im Datensatz bereits vorliegt. Die Variable Fahrtzw besitzt die Ausprägungen w für Werktags, u für Urlaubswerktage und s für Sonn- und Feiertage. Somit müssen wir in unseren Filter lediglich die Abfrage Fahrtzw == \"w\" einfügen.\n\nZST5116$Wotag &lt;- factor(ZST5116$Wotag,\n levels = c(1,2,3,4,5,6,7),\n labels = c(\"Mo\",\"Di\",\"Mi\",\"Do\",\"Fr\",\"Sa\",\"So\"))\n\n\ndata_werktag &lt;- ZST5116 |&gt;\n  filter(Fahrtzw == \"w\", Wotag %in% c(\"Di\", \"Mi\", \"Do\"))\n\ndata_werktag_mean &lt;- data_werktag |&gt;\n  group_by(Stunde) |&gt;\n  summarise(avg_KFZ_R1 = mean(KFZ_R1),avg_KFZ_R2 = mean(KFZ_R2))\n\ndata_werktag_mean$Anteil = (data_werktag_mean$avg_KFZ_R1/sum(data_werktag_mean$avg_KFZ_R1)*100)\n\nDiese Daten können wir nun analog zum ersten Teil dieser Aufgabe plotten:\n\nggplot(data = data_werktag_mean, aes(x = Stunde, y = avg_KFZ_R1, group = 1)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Verkehrsaufkommen mittlerer Werktage Zählstelle 5116 R1\",\n       x = \"Stunde\",\n       y = \"KFZ_R1 in KFZ pro Stunde\") +\n  theme_light()\n\n\n\n\n\n\n\n\nUm Ein Verständnis zu bekommen wie groß der Anteil der jeweiligen Stunde am Verkehrsaufkommen ist, können wir dies ebenfalls plotten:\n\nggplot(data = data_werktag_mean, aes(x = Stunde, y = Anteil, group = 1)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Verkehrsaufkommen mittlerer Werktage Zählstelle 5116 R1\",\n       x = \"Stunde\",\n       y = \"Prozentualer Anteil\") +\n  theme_light()\n\n\n\n\n\n\n\n\nOft möchte man nicht nur die Daten einer Zählstelle auswerten, sondern mehrere Zählstellen miteinander vergleichen oder Entwicklungen über Jahre auswerten. Um mehrere Zählstellen miteinander zu vergleichen gehen wir zuerst exakt so vor wie in Kapitel 3.2. Wir importieren hier nun die Datensätze der Zählstellen 5113,5116,5125 und 5128.\n\nZST5113 &lt;- read_csv2(\"data/zst5113_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\nZST5116 &lt;- read_csv2(\"data/zst5116_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\nZST5125 &lt;- read_csv2(\"data/zst5125_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\nZST5128 &lt;- read_csv2(\"data/zst5128_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\n\n\n\n\n\n\n\nMit Funktionen mehrere Datensätze einlesen\n\n\n\nBei einer großen Anzahl an Datensätze mit gleichen Einlesungsoperationen bieten sich Funktionen an, um effizienter zu arbeiten und mögliche Fehler bei copy-and-paste zu verhindern: Siehe dazu [Referenz zu anderem Kapitel] https://r4ds.hadley.nz/functions.html\n\n\nUm diese verschiedenen Datensätze in einem Datensatz zu kombinieren, verwenden wir die bind_rows()-Funktion des Pakets dplyr aus dem tidyverse. Dazu geben wir dem Befehl eine Liste der zu kombinierenden Datensätze mit list() und fügen mit .id = eine Identifizierungsspalte hinzu. Standardmäßig werden diese Variable der Identifizierungsspalte einfach durchnummeriert. Es bietet sich aber an die jeweilige Nummer oder den Namen der Zählstelle zu verwenden. In unserem Fall entscheiden wir uns für den Namen. Analog zu Kapitel 3.2 wandeln wir die Variable Zaehlstelle in einen Faktor mit den Namen als Ebenen um. Zusätzlich benennen wir auch die Wochentage wie bereits getan erneut um.\n\nall_data &lt;- bind_rows(list(ZST5113,ZST5116,ZST5125,ZST5128), .id = \"Zaehlstelle\")\n\nall_data$Zaehlstelle &lt;- factor(all_data$Zaehlstelle, levels = c(\"1\", \"2\", \"3\", \"4\"), labels = c(\"Bochum\", \"Wanne-Eickel\", \"Waltrop-Brambauer\", \"Wenden-Dahl\"))\n\nall_data$Wotag &lt;- factor(all_data$Wotag,\n levels = c(1,2,3,4,5,6,7),\n labels = c(\"Mo\",\"Di\",\"Mi\",\"Do\",\"Fr\",\"Sa\",\"So\"))\n\n\ndata_werktag_all &lt;- all_data |&gt;\n  filter(Fahrtzw == \"w\", Wotag %in% c(\"Di\", \"Mi\", \"Do\"))\n\ndata_werktag_mean_all &lt;- data_werktag_all |&gt;\n  group_by(Stunde, Zaehlstelle) |&gt;\n  summarise(avg_KFZ_R1 = mean(KFZ_R1),avg_KFZ_R2 = mean(KFZ_R2))\n\nWenn wir diese gefilterten Daten wie bereits gelernt darstellen, erhalten wir folgende Plots:\n\nggplot(data = data_werktag_mean_all, aes(x = Stunde, y = avg_KFZ_R1, group = Zaehlstelle, color = Zaehlstelle)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Verkehrsaufkommen mittlerer Werktage aller Zählstellen\",\n       x = \"Stunde\",\n       y = \"KFZ_R1\",\n       color = \"Wotag\") +\n  scale_color_viridis_d() +\n  theme_light()\n\n\n\n\n\n\n\n\nAnalog zu den Werktagen filtern wir unsere Daten nun für Samstage.Für die Sonntage ist ein Blick in die Datensatzbeschreiben (siehe oben) hilfreich. In den Daten werden Sonn- und Feiertage gemeinsam aufgeführt, sodass wir unseren Filter dort nicht anwenden können.\n\n#Samstag\ndata_samstag_all &lt;- all_data |&gt;\n  filter(Fahrtzw == \"w\", Wotag == \"Sa\")\n\ndata_samstag_mean_all &lt;- data_samstag_all |&gt;\n  group_by(Stunde, Zaehlstelle) |&gt;\n  summarise(avg_KFZ_R1 = mean(KFZ_R1),avg_KFZ_R2 = mean(KFZ_R2))\n\n`summarise()` has grouped output by 'Stunde'. You can override using the\n`.groups` argument.\n\n#Sonntag\ndata_sonntag_all &lt;- all_data |&gt;\n  filter(Wotag == \"So\")\n\ndata_sonntag_mean_all &lt;- data_sonntag_all |&gt;\n  group_by(Stunde, Zaehlstelle) |&gt;\n  summarise(avg_KFZ_R1 = mean(KFZ_R1),avg_KFZ_R2 = mean(KFZ_R2))\n\n`summarise()` has grouped output by 'Stunde'. You can override using the\n`.groups` argument.\n\n\nPlot für Samstage:\n\nggplot(data = data_samstag_mean_all, aes(x = Stunde, y = avg_KFZ_R1, group = Zaehlstelle, color = Zaehlstelle)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Verkehrsaufkommen an Samstagen aller Zählstellen\",\n       x = \"Stunde\",\n       y = \"KFZ_R1\",\n       color = \"Wotag\") +\n  scale_color_viridis_d() +\n  theme_light()\n\n\n\n\n\n\n\n\nPlot für Sonntage:\n\nggplot(data = data_sonntag_mean_all, aes(x = Stunde, y = avg_KFZ_R1, group = Zaehlstelle, color = Zaehlstelle)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Verkehrsaufkommen an Sonntagen aller Zählstellen\",\n       x = \"Stunde\",\n       y = \"KFZ_R1\",\n       color = \"Wotag\") +\n  scale_color_viridis_d() +\n  theme_light()\n\n\n\n\n\n\n\n\n\n\n3.2.3 Aufgabe 2 c): 50. Stunde\nAls einen weiteren wichtigen Kennwert schauen wir uns das Verkehrsaufkommen in der 50. Stunde an. Für eine rein deskriptive Beschreibung der 50. Stunden können wir den Datensatz absteigend sortieren und dann den 50. Wert auswählen. Dazu benutzen wir erneut die arrange()-Funktion, dieses Mal aber mit dem Zusatz desc()(kurz für englisch descending = absteigend). Um eine Reihe anhand der Position auszuwählen, verwenden wir den slice()-Befehl. Dies leiten wir nun an die select()-Funktion weiter, die es uns ermöglicht anhand des Namens auszuwählen, welche Variablen wir für unsere Darstellung behalten möchten. In diesem Fall wählen wir das Datum (Datum), den Wochentag (Wotag), die Stunde des Tages (Stunde) und den tatsächlichen Verkehrswert (KFZ_R1) aus.\n\nZST5116_50 &lt;- ZST5116 |&gt; \n    arrange(desc(KFZ_R1)) |&gt;\n    slice(50) |&gt;\n  select(Datum,Wotag,Stunde,KFZ_R1)\n\nMit der Funktion kable() aus dem Paket kableExtra können wir dies nun tabellarisch darstellen. Wir sehen, dass es sich um Freitag (Wotag 5), den 11. Februar (Datum 220211) in der 14. Stunde handelt und in diesem zeitraum 3173 KFZ erfasst wurden.\n\nkable(ZST5116_50)\n\n\n\n\nDatum\nWotag\nStunde\nKFZ_R1\n\n\n\n\n220211\n5\n14\n3173\n\n\n\n\n\nDies zeigt uns aber nur den einzelnen Wert der 50. Stunde ohne dass wir ihn in Relation zu den anderen Werten setzen können. Ein wichtiger Bestandteil der 50. Stunde ist die Einschätzung des Verkehrsaufkommens und wie hoch der Anteil der 50. Stunde im Vergleich zur Topstunde ist. Dafür bietet sich eine Darstellung als Säulendiagramm an.\nWir erstellen einen neuen Datensatz, der das Verkehrsaufkommen in absteigender Reihenfolge darstellt (dieselbe Vorgehensweise wie für unsere deskriptive Beschreibung). Im nächsten Schritt fügen wir eine Variable hinzu, die für uns die Position im Datensatz durchnummeriert (simple Lösung mit 1:nrow()).\n\n# Erstellen des Streudiagramms für den stündlichen DTV Zählstelle 5116 Richtung 1\nZST5116_top &lt;- ZST5116 |&gt;\n  arrange(desc(KFZ_R1))\n\nZST5116_top$Nummer = 1:nrow(ZST5116_top)\n\nNun können wir unsere Säulendiagramme plotten: Um nicht alle (in unserem Fall 8760) Beobachtungen zu plotten, wird der zu plottende Datensatz mithilfe von dem Zusatz [1:80,] bei der Festlegung des Datensatzes auf die ersten 80 Beobachtungen reduziert. Es bietet sich an , die 50. Stunde farblich hervorzuheben und mit einem Label zu versehen.\nDazu verwenden wir einen logischen Operator mit fill = Nummer == 50 und können dann mit scale_fill_manual() das Aussehen festlegen. Durch das Einfügen von values = c(\"black\", \"red\") bestimmen wir, dass für den Fall dass der Operator stimmt ( also die 50. Stunde), die Farbe rot verwendet wird, andernfalls die Farbe schwarz. Der Zusatz guide = \"none\" sorgt dafür, dass diese Logikabfrage nicht in der Legende aufgeführt wird.\nDas Label wird mithilfe der Funktion geom_label, die analog zu bereits bekannten geoms aus ggplot2 funktioniert, erstellt. Wir filtern den Datensatz mit data = filter(ZST5116_top,Nummer == 50), sodass nur die 50. Stunde ein Label erhält und wählen als Inhalt des Labels den KFZ-Wert mit mapping = aes(label = KFZ_R1). Die restlichen Optionen dienen der Ästhetik:\n\nnudge_y verschiebt das Label um eine festgestelegte vertikale Distanz zur besseren Lesbarkeit. Für horizontale Positierung wird analog nudge_xverwendet.\nsize bestimmt die Größe des Labels.\nalpha stellt die Transparenz ein.\n\n\nggplot(data = ZST5116_top[1:80, ], aes(x = Nummer,y = KFZ_R1, fill = Nummer == 50, width = .65)) +\n  geom_bar(stat = \"identity\") +\n  labs(title = \"Verkehrsaufkommen pro Stunde Zählstelle 5116 Richtung 1\",\n       x = \"Sortierte Topstunde\",\n       y = \"Verkehrsaufkommen in Kfz/h\",\n       legend = \"Wochentag\") +\n  scale_fill_manual(values = c(\"grey\", \"red\"), guide = \"none\") +\n  geom_label(\n    data = filter(ZST5116_top,Nummer == 50), \n    mapping = aes(label = KFZ_R1),\n    nudge_y = 200, size = 4.5, alpha = 0.5\n  ) +\n  theme_light()\n\n\n\n\n\n\n\n\n\n\n3.2.4 Aufgabe 2 d): Schwerverkehr-Anteile über die Jahre\nNun schauen wir uns, wie wir den Verlauf der Schwerverkehr-Anteile über mehrere Jahre hinweg ansehen können. Dies kann z.B. bei der Beantwortung der Frage helfen, ob durch steigende Globalisierung auch der Anteil am Schwerverkehr steigt.\nUm mehrere Dateien gleichzeitig einzulesen, bietet es sich an eine function zu verwenden, damit dieser Schritt in einem Durchlauf erledigt wird und man mögliche Fehler beim Kopieren und Einfügen vermeidet.\nTO-DO: Erläuterungen\n\nlist_of_files &lt;- list.files(path = \"data_jw\",\n                            recursive = TRUE,\n                            pattern = \"\\\\.csv$\",\n                            full.names = TRUE)\n\ndf &lt;- readr::read_csv2(list_of_files, id = \"Jahr\", locale = locale(encoding = 'iso-8859-1'))\ndf$Jahr &lt;- str_remove_all(df$Jahr, \"[data_jw/Jawe]\")\ndf$Jahr &lt;- str_remove_all(df$Jahr, \"[.csv]\")\ndf$Jahr &lt;- as.numeric(df$Jahr)\n\ndf_NA &lt;- df |&gt;\n  filter(DTV_Kfz_MobisSo_Q != 'NA' & DTV_SV_MobisSo_Q != 'NA')\n\ndf_schwer &lt;- df_NA |&gt; \n  group_by(Jahr) |&gt; \n  summarise(SV = sum(DTV_SV_MobisSo_Q),Alle = sum(DTV_Kfz_MobisSo_Q),Anteil = (SV/Alle)*100)\n\n\nggplot(data = df_schwer, aes(x = Jahr, y = Anteil)) +\n  geom_bar(stat='identity', fill = \"blue\") +\n  labs(x = \"Jahr\", y = \"Anteil am gesamten Verkehrsaufkommen\") +\n  ggtitle(\"Anteil des Schwerverkehrs von 2003 bis 2018 in 1000\") +\n  scale_x_continuous(breaks=seq(2003,2018,1)) +\n theme_light()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Ausführliche Erläuterung der Musterlösung</span>"
    ]
  },
  {
    "objectID": "weitere_beispiele.html",
    "href": "weitere_beispiele.html",
    "title": "4  Weitere Anwendungsbeispiele",
    "section": "",
    "text": "4.1 Über alle Tage\nWir wollen nun die Daten der Zählstellen für alle Tage gemittelt vergleichen. Dazu verwenden wir unseren kombinierten Datensatz und gruppieren diesen mit group_by nach der Identifikationsvariable der Zählstelle (Zählstelle) und dem Wochentag (Wotag). Danach leiten wir diese Werte an die summarise()-Funktion weiter. Diese gibt für jede Kombination der Gruppierungsvariable eine Reihe aus. Dazu benötigen wir für Kombination ebenfalls die Mittelwerte für beide Fahrtrichtungen (KFZ_R1 und KFZ_R2). Diesen Datensatz speichern wir als neues Element.\nZST5113 &lt;- read_csv2(\"data/zst5113_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\nZST5116 &lt;- read_csv2(\"data/zst5116_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\nZST5125 &lt;- read_csv2(\"data/zst5125_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\nZST5128 &lt;- read_csv2(\"data/zst5128_2022.csv\", locale = locale(encoding = 'iso-8859-1'))\nall_data &lt;- bind_rows(list(ZST5113,ZST5116,ZST5125,ZST5128), .id = \"Zaehlstelle\")\n\nall_data$Zaehlstelle &lt;- factor(all_data$Zaehlstelle, levels = c(\"1\", \"2\", \"3\", \"4\"), labels = c(\"Bochum\", \"Wanne-Eickel\", \"Waltrop-Brambauer\", \"Wenden-Dahl\"))\n\nall_data$Wotag &lt;- factor(all_data$Wotag,\n levels = c(1,2,3,4,5,6,7),\n labels = c(\"Mo\",\"Di\",\"Mi\",\"Do\",\"Fr\",\"Sa\",\"So\"))\ndata_wochentag &lt;- all_data |&gt;\n  group_by(Zaehlstelle, Wotag) |&gt;\n  summarise(avg_KFZ_R1 = mean(KFZ_R1),avg_KFZ_R2 = mean(KFZ_R2))\nMit diesen Daten können wir nun bereits mit ggplot2 eine Grafik erstellen. Dazu verwenden wir grundsätzlich die verwendeten Funktionen aus Kapitel 3.2. Dieses Mal gruppieren und färben wir den Plot aber nach der Variable Zählstelle anstelle von Wotag.\nggplot(data = data_wochentag, aes(x = Wotag, y = avg_KFZ_R1, group = Zaehlstelle, color = Zaehlstelle, shape = Zaehlstelle)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Durchschnittlicher stündlicher Verkehr für alle Zählstellen\",\n        x = \"Wochentag\",\n        y = \"Verkehrsaufkommen Richtung 1 in Kfz/h\",\n        color = \"Zaehlstelle\",\n        shape = \"Zaehlstelle\") +\n  scale_colour_viridis_d() +\n  theme_light()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Weitere Anwendungsbeispiele</span>"
    ]
  },
  {
    "objectID": "weitere_beispiele.html#einen-wochentag-im-detail",
    "href": "weitere_beispiele.html#einen-wochentag-im-detail",
    "title": "4  Weitere Anwendungsbeispiele",
    "section": "4.2 Einen Wochentag im Detail",
    "text": "4.2 Einen Wochentag im Detail\nNun wollen wir uns einen Wochentag im Detail zwischen den verschiedenen Zählstellen vergleichen. Erneut filtern wir mit filter() unsere Daten so, dass in unserem Fall nur noch Dienstage übrig bleiben (Wotag == \"Di\") und speichern diesen Datensatz. Zur weiteren Verarbeitung gruppieren wir diesen Datensatz nach Zählstellen und Stunde (group_by(Zählstelle, Stunde)) und erstellen mit summarise() für jede Stunde jeder Zählstelle eine neue Reihe und erzeugen den Mittelwert mit mean().\nTO-DO: Angabe der prozentualen stündlichen Anteile (+ Tabelle)\n\ndata_dienstag &lt;- all_data |&gt;\n  filter(Wotag == \"Di\")\n\n\ndata_dienstag_mean &lt;- data_dienstag |&gt;\n  group_by(Zaehlstelle, Stunde) |&gt;\n  summarise(avg_KFZ_R1 = mean(KFZ_R1)) |&gt;\n  group_by(Zaehlstelle) |&gt;\n  mutate(Anteil = (avg_KFZ_R1/sum(avg_KFZ_R1))*100)\n\nDer erstellte Plot ist nahezu identisch mit dem aus Kapitel 4.1, nur werden auf der x-Achse jetzt die einzelnen Stunden des Dienstags aufgeführt.\n\nggplot(data = data_dienstag_mean, aes(x = Stunde, y = Anteil, group = Zaehlstelle, color = Zaehlstelle, shape = Zaehlstelle)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Durchschnittlicher stündlicher Verkehr dienstags R1\",\n        x = \"Stunde\",\n        y = \"Anteil am Verkehrsaufkommen Richtung 1 in Prozent\",\n        color = \"Zaehlstelle\",\n        shape = \"Zaehlstelle\") +\n  scale_colour_viridis_d() +\n  theme_light()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Weitere Anwendungsbeispiele</span>"
    ]
  },
  {
    "objectID": "weitere_beispiele.html#schwer-und-leichtverkehr",
    "href": "weitere_beispiele.html#schwer-und-leichtverkehr",
    "title": "4  Weitere Anwendungsbeispiele",
    "section": "4.3 Schwer und Leichtverkehr",
    "text": "4.3 Schwer und Leichtverkehr\nTO-DO: Erläuterungen\n\ndata_schwer &lt;- all_data |&gt;\n  group_by(Zaehlstelle, Wotag) |&gt;\n  summarise(avg_LKW_R1 = mean(Lkw_R1),avg_LKW_R2 = mean(Lkw_R2))\n\n# Erstellung des Streudiagrammes Richtung 1. \nggplot(data = data_schwer, aes(x = Wotag, y = avg_LKW_R1, group = Zaehlstelle, color = Zaehlstelle)) +\n  geom_point(size = 2) +\n  geom_line(linewidth = 1) +\n  labs(title = \"Durchschnittlicher stündlicher Schwerverkehr für alle Zählstellen R1\",\n       x = \"Wochentag\",\n       y = \"LKW_R1\",\n       color = \"Zaehlstelle\") +\n  scale_colour_viridis_d() +\n  theme_light()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Weitere Anwendungsbeispiele</span>"
    ]
  }
]